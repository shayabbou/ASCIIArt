/**
 * The image package contains classes related to image processing and manipulation.
 * It includes classes for loading, editing, and analyzing images.
 */
package image;

import java.awt.*;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedHashMap;

/**
 * The EditImage class represents an image editing tool that performs padding, slicing,
 * and brightness calculation.
 * It allows users to modify images for further processing.
 */
public class EditImage {
    private Image image;
    private LinkedHashMap<Image, Double> subImages;
    private Color [][] newPixelArray;

    /**
     * Constructs an EditImage object with the provided original image and resolution.
     * @param orgImage The original Image object to edit.
     * @param resolution An integer representing the resolution of the edited image.
     * @throws IOException If there is an error loading the image file.
     */
    public EditImage(Image orgImage, int resolution) throws IOException{
        this.image = paddImage(orgImage);
        this.subImages = sliceImage(resolution);
    }

    /**
     * Gets the padded image.
     * @return An Image object representing the padded image.
     */
    public Image getPaddImage(){
        return image;
    }

    /**
     * Gets the sub-images generated by slicing the original image.
     * @return A LinkedHashMap mapping sub-images to their brightness values.
     */
    public LinkedHashMap<Image, Double> getSubImages(){
        return subImages;
    }

    private LinkedHashMap<Image, Double> sliceImage(int resolution){
        int size = image.getWidth()/resolution;
        LinkedHashMap<Image, Double> sliceImages = new LinkedHashMap<>();
        int row = 0 , col = 0;
        Color[][] partArray = new Color[size][size];
        while (row < image.getHeight()) {
            while (col < image.getWidth()) {
                for (int i = 0; i < size; i++) {
                    for (int j = 0; j < size; j++) {
                        partArray[i][j] = image.getPixel(row, col);
                        col++;
                    } col = col-size;
                    row++;
                } row = row - size;
                col += size;
                Image partImage = new Image(partArray, size, size);
                double brightnessAvg = imageBrightness(partImage, size);
                sliceImages.put(partImage, brightnessAvg);
            } row += size;
            col = 0;
        } return sliceImages;
    }

    private double imageBrightness(Image image, int size){
        double greyPixel = 0;
        double greyNormal = 0;
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                Color pixel = image.getPixel(i, j);
                greyPixel = pixel.getRed() * 0.2126 + pixel.getGreen() * 0.7152
                        + pixel.getBlue() * 0.0722;
                greyNormal += greyPixel;
            }
        }
        return (greyNormal/255)/(size*size);
    }

    private Image paddImage(Image orgImage) throws IOException {
        int width = orgImage.getWidth();
        int height = orgImage.getHeight();;
        int widthPowerOf2 = getClosestPowerOf2(width);
        int heightPowerOf2 = getClosestPowerOf2(height);
        int yPadding = (heightPowerOf2-height)/2;
        int xPadding = (widthPowerOf2-width)/2;
        if(widthPowerOf2 == width && heightPowerOf2 == height){
            return orgImage;
        }
        newPixelArray = new Color[heightPowerOf2][widthPowerOf2];
        int row = 0;
        fillWhitePixels(row,yPadding,widthPowerOf2);
        row += yPadding;
        fillOriginalPixel(row,widthPowerOf2, heightPowerOf2,xPadding,yPadding, orgImage);
        row+=height;
        fillWhitePixels(row,heightPowerOf2,widthPowerOf2);
        return new Image(newPixelArray, widthPowerOf2, heightPowerOf2);
    }

    private void fillWhitePixels(int row, int yPadding , int widthPowerOf2){
        for(; row < yPadding; row++){
            newPixelArray[row] = new Color[widthPowerOf2];
            Arrays.fill(newPixelArray[row], Color.WHITE);
            }
    }
    private void fillOriginalPixel(int row,int widthPowerOf2,
        int heightPowerOf2,int xPadding,int yPadding, Image orgImage) {
        for (; row < (heightPowerOf2 - yPadding); row++) {
            newPixelArray[row] = new Color[widthPowerOf2];
            int col = 0;
            for (; col < xPadding; col++) {
                newPixelArray[row][col] = Color.WHITE;
            }
            for (; col < (widthPowerOf2 - xPadding); col++) {
                newPixelArray[row][col] = orgImage.getPixel(row - yPadding, col - xPadding);
            }
            for (; col < widthPowerOf2; col++) {
                newPixelArray[row][col] = Color.WHITE;
            }
        }
    }
    private int getClosestPowerOf2(int x){
        if((x & (x-1)) == 0){
            return x;
        }
        else{
            int exponent = (int) Math.ceil(Math.log(x) / Math.log(2));
            return (int) Math.pow(2, exponent);
        }
    }
}